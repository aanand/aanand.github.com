<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://aanandprasad.com/</id>
  <title>Aanand Prasad</title>
  <updated>2011-07-05T20:13:00Z</updated>
  <link rel="alternate" href="http://aanandprasad.com/"/>
  <link rel="self" href="http://aanandprasad.com/articles.xml"/>
  <author>
    <name>Aanand Prasad</name>
    <uri>http://aanandprasad.com/</uri>
  </author>
  <entry>
    <id>tag:aanandprasad.com,2011-07-05:/articles/jquery-tappable/</id>
    <title type="html">Better Touch Behaviour with jquery.tappable.js</title>
    <published>2011-07-05T20:13:00Z</published>
    <updated>2011-07-07T09:39:00Z</updated>
    <link rel="alternate" href="http://aanandprasad.com/articles/jquery-tappable/"/>
    <content type="html">&lt;details&gt;&lt;summary&gt;&lt;p&gt;Mobile web apps shouldn’t pretend to be native, but click behaviour in Mobile Safari is unacceptably ugly. Unfortunately, taking control of it is more involved than it perhaps ought to be. &lt;a href='https://github.com/aanand/jquery.tappable.js'&gt;jquery.tappable.js&lt;/a&gt; does (most of) the hard work for you.&lt;/p&gt;&lt;/summary&gt;&lt;/details&gt;&lt;hr/&gt;&lt;p&gt;I hope we can all agree that &lt;a href="http://cvil.ly/2011/06/19/pretenders-why-mobile-web-apps-should-stop-trying-to-act-like-native-apps/"&gt;mobile web apps shouldn’t pretend to be native apps&lt;/a&gt;, but I don’t like the thought of having to accept the current state of most mobile apps as the hand we’ve been dealt. The whole business feels somewhat 2000-era, which is frankly weird—we’ve spent a good decade improving the look and feel of apps in the browser, but the majority of mobile web apps seem content with a half-hearted grey-boxes-and-lines style and a rigid, transitionless interactivity.&lt;/p&gt;

&lt;p&gt;Does the responsibility lie with the vendors of mobile browsers? Partially. Apple are only now getting round to adding &lt;a href="http://cubiq.org/ios5-the-first-true-web-app-ready-platform"&gt;native support for scrollable elements&lt;/a&gt;: so far, we’ve been stuck with a range of lovingly crafted fakeries that range from ‘pathetic’ to ‘uncanny valley’. The problem goes beyond the slow pace of change, though—even when the functionality required to implement higher-quality interaction &lt;em&gt;is&lt;/em&gt; in place, it’s often in such a way as to leave an inordinate amount of work to the app developer. A perfect example of this is the default behaviour of ‘clickable’ (or, rather, &lt;em&gt;tappable&lt;/em&gt;) elements in Mobile Safari.&lt;/p&gt;

&lt;p&gt;Tap a link, a button or indeed any element with a &lt;code&gt;click&lt;/code&gt; event defined, and two unpleasant things happen. First, &lt;em&gt;nothing&lt;/em&gt;, for around 300 milliseconds. Then, an ugly dark-grey overlay—you know the one I’m talking about. Compared to the responsiveness of tappable UI elements in native apps, using a mobile app where every element behaves this way feels like operating your iPhone with someone else’s finger.&lt;/p&gt;

&lt;p&gt;In developing &lt;a href="http://nnnnext.com"&gt;nnnnext&lt;/a&gt;, I quickly came to the decision that this wasn’t good enough, and set about trying to fix it. While &lt;a href="http://css-infos.net/property/-webkit-tap-highlight-color"&gt;removing the overlay&lt;/a&gt; was easy enough, it quickly became obvious that iOS’ touch behaviour is more complicated than I intitially suspected, primarily in that &lt;em&gt;it treats a “long tap” differently from a “short tap”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perform a short tap (i.e. literally just &lt;em&gt;tap&lt;/em&gt; the screen), and the element is immediately highlighted and the appropriate action executed. Perform a long tap (keeping your finger down for a moment), and the element is highlighted after a short delay (around 150ms) and the action executed when you lift your finger—unless you move your finger first, in which case the highlight is immediately removed and the action cancelled.&lt;/p&gt;

&lt;p&gt;The reason for the long-tap highlight delay became apparent after I’d coded my initial implementation: if the element is immediately highlighted when you put your finger down, then every time you scroll you’ll get a flash-of-highlight if you happen to start your scroll by putting your finger on that element. This is, I believe, why the delay is only in place on large, column-spanning elements of the type you can’t avoid touching when you scroll, while buttons and other small widgets react the moment you touch them.&lt;/p&gt;

&lt;p&gt;I realised some of this only after implementing an incorrect solution, releasing it and blogging my ignorance. Another fact I overlooked is that Mobile Safari’s behaviour &lt;em&gt;only&lt;/em&gt; deviates from the rest of the OS on short taps. Long-tap behaviour is the same, but with short taps, both highlighting &lt;em&gt;and&lt;/em&gt; action are delayed, and for around twice as long as the long-tap highlight delay! The reason for this (though I failed to perceive this blindingly obvious fact at the time) is Safari’s &lt;em&gt;double-tap-to-zoom feature&lt;/em&gt;—if there were no delay, or if it were much shorter, double-tapping would be impossible.&lt;/p&gt;

&lt;p&gt;In most mobile-optimised web apps, however, zooming isn’t even enabled, rendering any short-tap delay worse than useless. Here, then, is our desired behaviour, expressed in terms of browser events:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;Event order&lt;/th&gt;
&lt;th&gt;Desired effect&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;touchstart, timeout, touchend&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Highlight on timeout, fire callback on touchend (long tap)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;touchstart, touchend, timeout&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Highlight and fire callback on touchend (short tap)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;touchstart, timeout, touchmove, touchend&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Highlight, then de-highlight on touchmove (long tap cancelled by scrolling)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;touchstart, touchmove, timeout, touchend&lt;/td&gt;
&lt;td style="text-align: left;"&gt;None (scroll)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;touchstart, touchmove, touchend, timeout&lt;/td&gt;
&lt;td style="text-align: left;"&gt;None (scroll)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;p&gt;I promised up there in the first paragraph that I’d done the hard work for you, and here you go: &lt;a href="https://github.com/aanand/jquery.tappable.js"&gt;jquery.tappable.js&lt;/a&gt; implements this behaviour, and falls back to &lt;code&gt;click&lt;/code&gt; events in desktop browsers for good measure.&lt;/p&gt;

&lt;p&gt;It deviates from the above table in one respect, however—the highlight class is removed (or, in the case of a short tap, not added) before firing the callback. This is a matter of code aesthetics for me: I don’t want a library or plugin I’m using to add a transient class to an element without cleaning up after itself. When I need the highlight class to stick around longer (which in the nnnnext codebase is the exception, not the rule), I add it again in the callback function.&lt;/p&gt;

&lt;p&gt;Anyway, examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Basic usage
$(element).tappable(function() { console.log("Hello World!") })

// Add a delay
$(element).tappable({
  callback:   function() { console.log("Hello World!") },
  touchDelay: 150
})

// Don't cancel taps when the user moves their finger
$(element).tappable({
  callback:     function() { console.log("Hello World!") },
  cancelOnMove: false
})

// Don't highlight the element OR fire the callback unless a
// specified condition is met
$(element).tappable({
  callback: function()   { console.log("Hello World!")      },
  onlyIf:   function(el) { return $(el).hasClass('enabled') }
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have fun!&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:aanandprasad.com,2011-05-20:/articles/prototype-chains-and-coffeescript-subclasses/</id>
    <title type="html">Prototype Chains and CoffeeScript Subclasses</title>
    <published>2011-05-20T13:16:00Z</published>
    <updated>2011-05-20T13:16:00Z</updated>
    <link rel="alternate" href="http://aanandprasad.com/articles/prototype-chains-and-coffeescript-subclasses/"/>
    <content type="html">&lt;details&gt;&lt;summary&gt;&lt;p&gt;In developing &lt;a href='http://nnnnext.com'&gt;nnnnext.com&lt;/a&gt;, I tackled a surprising number of problems I’d not faced before in my web development career. Here’s one of the more interesting ones, with what I think is a pretty cute solution.&lt;/p&gt;&lt;/summary&gt;&lt;/details&gt;&lt;hr/&gt;&lt;p&gt;Context, briefly: nnnnext is a todo list for your music. It’s a single-page JavaScript app written in &lt;a href="http://jashkenas.github.com/coffee-script/"&gt;CoffeeScript&lt;/a&gt; and utilising &lt;a href="http://documentcloud.github.com/backbone/"&gt;Backbone.js&lt;/a&gt; for &lt;a href="http://twitter.com/hylomorphism/status/71202209618067457"&gt;lightweight&lt;/a&gt; MVC. Importantly, it has two similar-but-separate user interfaces: one for desktop web browsers, and another for multitouch devices.&lt;/p&gt;

&lt;p&gt;Both interfaces are implemented as a set of classes (provided by CoffeeScript’s &lt;a href="http://jashkenas.github.com/coffee-script/#classes"&gt;simple classes implementation&lt;/a&gt;) that represent the different UI views. Each UI requires slightly different behaviour for &lt;em&gt;some&lt;/em&gt; views. For example, an element might contain a button that (in the desktop UI) appears when the element is hovered, and (in the touch UI) appears/disappears when the element is tapped. Consequently, some view classes are subclassed in one or both UIs in order to implement these differences. The class structure might look like this (implementation code omitted):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Views   = {}
Desktop = {}
Touch   = {}

class Views.Widget   extends Backbone.View
class Views.Thinger  extends Backbone.View
class Views.Sprocket extends Backbone.View

class Desktop.Widget extends Views.Widget

class Touch.Widget   extends Views.Widget
class Touch.Thinger  extends Views.Thinger&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Whatever you think of classical object-orientation and inheritance, it’s an undeniably good fit for MVC-style UI code—subclasses and the &lt;code&gt;super&lt;/code&gt; keyword make augmentation of behaviour very straightforward&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.)&lt;/p&gt;

&lt;p&gt;So how, at runtime, might we instantiate the appropriate class? Running all instantiations through a helper method would certainly work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# assume the existence of a `Mobile` boolean variable

makeViewObject: -&amp;gt; (name, args...)
  UI    = if Mobile then Touch else Desktop
  klass = UI[name] || Views[name]

  new klass(args...)

makeViewObject("Widget")   # =&amp;gt; new Desktop.Widget OR new Touch.Widget
makeViewObject("Thinger")  # =&amp;gt; new Desktop.Thinger OR new Views.Thinger
makeViewObject("Sprocket") # =&amp;gt; new Views.Sprocket&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…and if you’re most people, you’ll stop there. I, on the other hand, had just read Isaac Z. Schlueter’s &lt;a href="http://blog.izs.me/post/4731036392/evolution-of-a-prototypal-language-user"&gt;Evolution of a Prototypal Language User&lt;/a&gt;, hadn’t done anything fun with prototype chains in years and didn’t like the idea of this unsightly helper method peppering my code. So I got to work.&lt;/p&gt;

&lt;p&gt;Instead of &lt;code&gt;Views&lt;/code&gt;, &lt;code&gt;Desktop&lt;/code&gt; and &lt;code&gt;Touch&lt;/code&gt; being plain objects, we create a &lt;code&gt;ViewShop&lt;/code&gt; function, point &lt;code&gt;Views&lt;/code&gt; at its prototype and make &lt;code&gt;Desktop&lt;/code&gt; and &lt;code&gt;Touch&lt;/code&gt; new &lt;code&gt;ViewShop&lt;/code&gt;s, so that property access falls back to &lt;code&gt;ViewShop.prototype&lt;/code&gt;, which we’ve just aliased to &lt;code&gt;Views&lt;/code&gt;… look, I’ll just show you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewShop = -&amp;gt;

Views   = ViewShop.prototype
Desktop = new ViewShop
Touch   = new ViewShop&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, after defining the view classes, access any property of &lt;code&gt;Desktop&lt;/code&gt; or &lt;code&gt;Touch&lt;/code&gt;, and prototype chaining works its magic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Desktop.Widget   # =&amp;gt; Desktop.Widget
Desktop.Thinger  # =&amp;gt; Views.Thinger
Desktop.Sprocket # =&amp;gt; Views.Sprocket

Touch.Widget     # =&amp;gt; Touch.Widget
Touch.Thinger    # =&amp;gt; Touch.Thinger
Touch.Sprocket   # =&amp;gt; Views.Sprocket&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need only make a &lt;code&gt;UI&lt;/code&gt; variable that points to the right &lt;code&gt;ViewShop&lt;/code&gt;, and we’re done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UI = if Mobile then Touch else Desktop

new UI.Widget   # =&amp;gt; new Desktop.Widget OR new Touch.Widget
new UI.Thinger  # =&amp;gt; new Desktop.Thinger OR new Views.Thinger
new UI.Sprocket # =&amp;gt; new Views.Sprocket&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well anyway, I like it.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;&lt;li id="fn:1"&gt;
&lt;p&gt;I should be careful about using the word “undeniably” though. I’m no expert on object systems. If you feel you can reasonably deny it, I’d love to &lt;a href="mailto:aanand.prasad@gmail.com"&gt;hear from you&lt;/a&gt;!&lt;/p&gt;
&lt;a href="#fnref:1" rev="footnote"&gt;↩&lt;/a&gt;
&lt;/li&gt;&lt;/ol&gt;
&lt;/div&gt;</content>
  </entry>
</feed>
